> ## 闪存存储的重构与系统构建技术
>
> 陆游游 杨者 舒继武

### 传统架构的问题与解决方案

[TOC]



#### 起因：

历史原因，为兼容传统的磁盘读写接口引用了FTL（flash translation layer闪存转换层），造成冗余结构，没用充分发挥SSD自身的优势。

#### 闪存特性

1. 擦除写，只可以控制充电，放电直接归零。（猜测与闪存的不易失性相关，非可控掉电影响数据保存）

2. 读写擦粒度不同，读写粒度为page（短百微妙级），擦除粒度为block（百毫秒级），为block的优势体现在避免频繁擦除降低性能

3. 擦写次数有限，擦写次数过多时闪存单元的数据不可靠（电子元器件的损耗？）。

4. 闪存转换层功能：

   - 地址映射，从逻辑页到物理页

   - 垃圾回收，将旧数据标记为失效，进入待回收，块内失效页达到一定数量对块进行擦除。

   - 磨损均衡，对每个块的擦写次数近似相同，避免某些块提前报废，变为坏块。

   - > 闪存转换层屏蔽了很多闪存介质的特性，但从
     > 固态盘层次上仍具有一些与磁盘不同的表现．由于
     > 固态盘内部存在通道级、芯片级、Ｐｌａｎｅ级等多个级
     > 别的并发，固态盘 内 部可以 提供极高的，高 于当前
     > ＳＡＴＡ 和ＰＣＩｅ接口的带宽．因而，固态盘在读操作
     > 的带宽可接近于硬件接口带宽，写带宽由于闪存写
     > 延迟稍高略低于读带宽．在随机读写方面，固态盘提
     > 供了较好的随机读性能，但随机写性能较差．整体而
     > 言，由于介质的差异，固态盘与磁盘存在较大的差异．

#### 存在问题

1. 功能冗余，存储系统软件和闪存转换层功能相近（地址映射等）
2. 维度缺失，采用磁盘设计思维，没有考虑闪存特性。
3. 优化错配？？？，引入trim命令

#### 架构的演变

1. 设备内FTL架构
   - ![image-20200727104849870](C:\Users\yangyiming\AppData\Roaming\Typora\typora-user-images\image-20200727104849870.png)
2. 设备外FTL架构
   - ![image-20200727104913310](C:\Users\yangyiming\AppData\Roaming\Typora\typora-user-images\image-20200727104913310.png)
3. 软件直管闪存架构
   - ![image-20200727104918894](C:\Users\yangyiming\AppData\Roaming\Typora\typora-user-images\image-20200727104918894.png)
4. 开放可编程闪存架构
   - ![image-20200727104923997](C:\Users\yangyiming\AppData\Roaming\Typora\typora-user-images\image-20200727104923997.png)

#### 开放通道的存储系统OC-SSD

1. 文件系统，F2FS,DFS,ReconFS,OFSS,ALFS,ParaFS

   > - #### 日志的三个级别（书里写的关于回写和顺序两种模式不同的更细节的解释）
   >
   >   在很多日志文件系统（如：[ext3](http://zh.wikipedia.org/wiki/Ext3), [ReiserFS](http://zh.wikipedia.org/wiki/ReiserFS)）中，可以选择三个级别的日志：回写（writeback）、顺序（ordered）和数据（data）。
   >
   >   ##### 回写
   >
   >   在回写模式中，只有[元数据](http://zh.wikipedia.org/wiki/元数据)被记录到日志中，数据被直接写入主文件系统。这种模式提供较好的性能，但有较大的风险。例如，在增大文件时，数据还未写入就发生崩溃，那么文件系统恢复后文件后面就可能出现垃圾数据。
   >
   >   ##### 顺序
   >
   >   在顺序模式中，只有[元数据](http://zh.wikipedia.org/wiki/元数据)被记录到日志中，但在日志被标记为提交前，数据会被写入文件系统。在这种模式下，如果在增大文件时，数据还未写入就发生崩溃，那么在恢复时这个事务会被简单的撤销，文件保持原来的状态。
   >
   >   ##### 数据
   >
   >   在数据模式中，[元数据](http://zh.wikipedia.org/wiki/元数据)和文件内容都先被写入日志中，然后在提交到主文件系统。这提高了安全性，但损失性能，因为所有数据要写入两次[[1\]](http://zh.wikipedia.org/wiki/日志文件系统#cite_note-ibm-1)。在这种模式下，如果在增大文件时，发生崩溃，那么可能有两种情况：
   >
   >   - 日志完整：这时事务会被重新执行，修改会被提交到主文件系统
   >   - 日志不完整：这时主文件系统还未被修改，只需要简单放弃这个事务

2. 键值存储系统，LOCS，DIDA-Cache，FlashKV

3. 分布式存储系统，OCStore

#### 近数据闪存系统

1. 事务闪存
2. 对象闪存
3. 设备内文件系统
4. 专用加速内存
5. 通用加速内存